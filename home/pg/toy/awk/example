# format
awk '{print $1, $4}' FILE # ',' to seperate output column (default [ ])
awk '{printf "%-8s %-8s\n", $1, $2}' FILE

# filter
awk '$3==0 && $6=="LISTEN"' FILE
awk '$3>0 {print $0}' FILE
awk '$3==0 && $6=="LISTEN" || NR==1' FILE # NR==1 => #(line) of table header
# so content in {} used to *format* print

# built-in vars
# $0    current line (one line as one *record*)
# $1-$n #(column)
# FS    seperator between column (default: [ \t])
# NR    total # of lines
# FNR
# RS    input line seperator (default [\n])
# OFS   output column seperator (default: [ ])
# ORS   output line seperator (default: [\n])
# FILENAME $filename
awk '$3==0 && $6=="ESTABLISHED" || NR==1 {printf "%02s %02s %-20s %-20s %s\n",NR, FNR, $4,$5,$6}' FILE
awk 'BEGIN{FS=":"} {print $1, $3, $6}' /etc/passwd
awk -F: '{..}'  # same as above
awk -F '[;:]'   # multi-seperator

# regex match
# ~/PATTERN/    match PATTERN
# !~/PATTERN/   match non-PATTERN
awk '$6~/FIN/ || NR==1 {print NR,$4,$5,$6}' OFS="\t" FILE
awk '/LISTEN/' FILE   # as grep

# split to parts
awk 'NR!=1{print > $6}' FILE # '>' means redirect to new-files, each named "$6" according to "$6"
awk 'NR!=1{print $4,$5 > $6}' FILE # formattd


# sequences
awk 'NR!=1{if($6~/TIME|ESTABLISHED/) print > "1.txt";
           else if($6~/LISTEN/) print > "2.txt";
           else print > "3.txt"}' FILE
# BEGIN{before process lines}
# END{after process lines}
# {do when process each line}
awk 'NR!=1{a[$6]++;} END {for (i in a) print i ", " a[i];}' # count states('a[]' as a map)


# vim: set ft=sh:
