Tips:
  代码段DPL 也即 新的CPL

数据权限检查: CPL <= DPL

控制权转移检查
JMP, CALL:
- 段内无检查
- 段间
  - 非一致代码段: CPL == 目标代码段DPL && 目标代码段选择子RPL <= 目标代码段DPL
  - 一致代码段:   CPL >= DPL(类似普通程序中的系统调用?), 不检查RPL, 不改变CPL

调用门(让低特权代码调用高特权代码):
使用调用门会发生堆栈切换, 不同的特权等级对应不同的堆栈(说白了其实是SS和ESP变了, 这些保存在
TSS中), 在CALL(带特权级变换的长CALL)转移中:
- 当前的SS和ESP会被暂时保存
- 然后从TSS中加载新的SS和ESP
- 并将之前暂时保存的压入新栈
- 接着*复制*调用参数(Param Count决定个数)到新栈
- 当前CS和EIP压新栈
- 加载调用门中指定的CS和EIP并开始执行

- CALL: CPL <= 调用门DPL && RPL <= 调用门DPL && 目标段DPL <= CPL
  (反之RET可以从高跳到低)
- JMP:  CPL <= 调用门DPL && RPL <= 调用门DPL
  - 非一致代码段: 目标段DPL <= CPL
  - 一致代码段:   目标段DPL == CPL
